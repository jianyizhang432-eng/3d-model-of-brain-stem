<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>模型查看器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: #2b2b2b;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        header {
            text-align: center;
            padding: 0.6rem 1rem;
            background: #323232;
            border-bottom: 1px solid #404040;
            flex-shrink: 0;
        }
        
        h1 {
            font-size: 1.2rem;
            margin-bottom: 0.15rem;
            color: #ffffff;
        }
        
        .subtitle {
            font-size: 0.75rem;
            opacity: 0.7;
        }
        
        .container {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        
        .model-container {
            flex: 1;
            position: relative;
            background: #3c3c3c;
        }
        
        #model-viewer {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .controls {
            width: 200px;
            background: #323232;
            border-left: 1px solid #404040;
            padding: 0.7rem;
            overflow-y: auto;
            flex-shrink: 0;
        }
        
        .control-group {
            margin-bottom: 1rem;
        }
        
        h2 {
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            color: #ffffff;
            border-bottom: 1px solid #404040;
            padding-bottom: 0.3rem;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }
        
        button {
            background: #404040;
            border: none;
            color: #e0e0e0;
            padding: 0.35rem 0.5rem;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 60px;
            font-size: 0.75rem;
        }
        
        button:hover {
            background: #4a4a4a;
        }
        
        .slider-container {
            margin-top: 0.3rem;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 0.15rem;
            font-size: 0.75rem;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 0.15rem 0;
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10;
            font-size: 0.9rem;
        }
        
        .progress-bar {
            width: 60%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: #1967d2;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
        }
        
        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
        }
        
        footer {
            text-align: center;
            padding: 0.4rem;
            background: #323232;
            border-top: 1px solid #404040;
            font-size: 0.65rem;
            color: #aaa;
            flex-shrink: 0;
        }
        
        .highlight-info {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 10px;
            border-radius: 3px;
            font-size: 0.75rem;
            z-index: 5;
            display: none;
            max-width: 220px;
            text-align: center;
            border: 1px solid #1967d2;
        }
        
        .search-container {
            margin-bottom: 1rem;
        }
        
        .search-input {
            width: 100%;
            padding: 0.4rem;
            background: #404040;
            border: 1px solid #555;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 0.75rem;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #1967d2;
        }
        
        .search-results {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #404040;
            border-radius: 3px;
            margin-top: 0.3rem;
            display: none;
        }
        
        .search-result-item {
            padding: 0.3rem;
            cursor: pointer;
            border-bottom: 1px solid #404040;
            font-size: 0.75rem;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item:hover {
            background: #404040;
        }
        
        .part-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .hide-checkbox {
            margin-right: 0.3rem;
        }
        
        .hidden-count {
            font-size: 0.7rem;
            color: #aaa;
            margin-top: 0.3rem;
        }
        
        .section-controls {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid #404040;
        }
        
        .section-button {
            width: 100%;
            margin-top: 0.3rem;
            background: #1967d2;
        }
        
        .section-button:hover {
            background: #1a73e8;
        }
        
        .slider-control {
            margin-top: 0.5rem;
        }
        
        .slider-control label {
            display: block;
            margin-bottom: 0.3rem;
            font-size: 0.75rem;
        }
        
        .direction-control {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }
        
        .direction-button {
            flex: 1;
            padding: 0.3rem;
            font-size: 0.7rem;
        }
        
        .direction-button.active {
            background: #1967d2;
        }
        
        /* 修改结构信息样式，移到左侧 */
        .structure-info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 280px;
            max-height: calc(100% - 120px);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 5px;
            padding: 10px;
            z-index: 5;
            display: none;
            overflow-y: auto;
            border: 1px solid #1967d2;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .structure-info-panel h2 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: #ffffff;
            border-bottom: 1px solid #404040;
            padding-bottom: 0.3rem;
        }
        
        .structure-info-content {
            margin-top: 0.5rem;
        }
        
        .structure-info-content h3 {
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
            color: #ffffff;
        }
        
        .structure-info-content p {
            font-size: 0.75rem;
            margin-bottom: 0.8rem;
            line-height: 1.4;
        }
        
        .structure-info-content .label {
            font-weight: bold;
            color: #90caf9;
            margin-right: 0.3rem;
        }
        
        .close-info {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 1rem;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-info:hover {
            color: #ffffff;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
        }
        
        .info-file-status {
            font-size: 0.7rem;
            margin-top: 0.3rem;
            color: #aaa;
        }
        
        .info-file-status.loaded {
            color: #4caf50;
        }
        
        .info-file-status.error {
            color: #f44336;
        }
    </style>
</head>
<body>
    <header>
        <h1>模型查看器</h1>
        <p class="subtitle">自动加载 model.glb 和 result.txt</p>
    </header>
    
    <div class="container">
        <div class="model-container">
            <div class="loading" id="loading">
                准备加载模型...
                <div class="progress-bar">
                    <div class="progress" id="progress"></div>
                </div>
                <p id="loading-text" style="margin-top: 6px; font-size: 0.7rem;">正在加载 model.glb...</p>
            </div>
            <canvas id="model-viewer"></canvas>
            
            <!-- 结构信息面板 - 移到左侧 -->
            <div class="structure-info-panel" id="structure-info-panel">
                <button class="close-info" id="close-info">×</button>
                <h2>结构信息</h2>
                <div class="structure-info-content" id="structure-info-content">
                    <h3 id="structure-name"></h3>
                    <p><span class="label">功能</span> <span id="structure-function"></span></p>
                    <p><span class="label">纤维联系</span> <span id="structure-fiber"></span></p>
                </div>
            </div>
            
            <div class="highlight-info" id="highlight-info"></div>
            <div class="info">
                鼠标左键旋转 | shift+左键平移 | 滚轮缩放 | 点击模型高亮结构
            </div>
            <div class="stats" id="stats">
                等待加载...
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h2>文件状态</h2>
                <div id="file-status">
                    <div id="model-status" class="info-file-status">正在加载 model.glb...</div>
                    <div id="info-status" class="info-file-status">正在加载 result.txt...</div>
                </div>
                <div class="button-group">
                    <button id="reset-view">重置视图</button>
                </div>
            </div>
            
            <div class="control-group">
                <h2>视图控制</h2>
                <div class="button-group">
                    <button id="show-all">显示所有结构</button>
                </div>
                <div class="slider-container">
                    <label for="zoom-level">缩放级别: <span id="zoom-value">100%</span></label>
                    <input type="range" id="zoom-level" min="1" max="500" step="1" value="100">
                </div>
            </div>
            
            <div class="control-group">
                <h2>结构搜索</h2>
                <div class="search-container">
                    <input type="text" id="part-search" class="search-input" placeholder="输入结构名称...">
                    <div class="search-results" id="search-results"></div>
                </div>
            </div>
            
            <div class="control-group">
                <h2>当前结构控制</h2>
                <div id="current-part-controls" style="display: none;">
                    <div id="current-part-name" style="font-size: 0.75rem; margin-bottom: 0.5rem;"></div>
                    <div class="part-controls">
                        <label>
                            <input type="checkbox" id="hide-part" class="hide-checkbox">
                            <span style="font-size: 0.75rem;">隐藏此结构</span>
                        </label>
                    </div>
                    <div class="section-controls" id="section-controls" style="display: none;">
                        <label>
                            <input type="checkbox" id="view-section" class="hide-checkbox">
                            <span style="font-size: 0.75rem;">查看切面</span>
                        </label>
                        <div class="slider-control" id="section-slider-control" style="display: none;">
                            <label for="section-offset">切面偏移: <span id="section-offset-value">0</span></label>
                            <input type="range" id="section-offset" min="-10" max="10" step="0.1" value="0">
                        </div>
                        <div class="direction-control" id="section-direction-control" style="display: none;">
                            <button id="direction-up" class="direction-button">上方</button>
                            <button id="direction-down" class="direction-button active">下方</button>
                        </div>
                        <button id="reset-section" class="section-button" style="display: none;">重置切面</button>
                    </div>
                </div>
                <div id="hidden-count" class="hidden-count" style="display: none;"></div>
            </div>
        </div>
    </div>
    
    <footer>
        <p>使用Three.js加载GLB模型 | 点击模型高亮结构并显示名称</p>
    </footer>

    <!-- 引入Three.js库 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // 初始化Three.js场景
        let scene, camera, renderer, controls;
        let model;
        let isLoading = false;
        let zoomLevel = 100;
        
        // 光源引用
        let ambientLight, directionalLight;
        
        // 光照强度设置（固定值）
        const ambientIntensity = 1.7;
        const directionalIntensity = 1.4;
        const emissiveIntensity = 10.0;
        
        // 高亮设置
        let highlightIntensity = 1.0;
        let highlightedObject = null;
        let originalMaterials = new Map();
        let pulseTime = 0;
        
        // 模型结构列表
        let partsList = [];
        
        // 隐藏的结构列表
        let hiddenParts = new Set();
        
        // 用于区分旋转操作和点击操作的变量
        let isRotating = false;
        let mouseDownPosition = null;
        const MOUSE_MOVE_THRESHOLD = 5; // 像素移动阈值
        
        // 当前选中结构的名称
        let currentPartName = null;
        
        // 切面查看相关变量
        let isSectionViewActive = false;
        let sectionPlane = null;
        let sectionOffset = 0; // 相对于平面结构的偏移量
        let sectionDirection = 'down'; // 'up' 或 'down'
        let currentPlaneY = 0; // 当前选中的平面结构的y轴位置
        
        // 结构信息数据
        let structureInfo = {};
        
        // 更新文件状态显示
        function updateFileStatus(elementId, message, isSuccess = false, isError = false) {
            const statusElement = document.getElementById(elementId);
            statusElement.textContent = message;
            statusElement.className = 'info-file-status';
            
            if (isSuccess) {
                statusElement.classList.add('loaded');
            } else if (isError) {
                statusElement.classList.add('error');
            }
        }
        
        // 加载结构信息文件
        function loadStructureInfo() {
            fetch('result.txt')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('无法加载结构信息文件');
                    }
                    return response.text();
                })
                .then(data => {
                    parseStructureInfo(data);
                    updateFileStatus('info-status', `已加载结构信息，共 ${Object.keys(structureInfo).length} 个结构`, true);
                    console.log('结构信息加载成功', structureInfo);
                })
                .catch(error => {
                    console.error('加载结构信息失败:', error);
                    updateFileStatus('info-status', '加载结构信息失败', false, true);
                });
        }
        
        // 解析结构信息文件 - 修改后的版本，处理带冒号和详细信息的格式
        function parseStructureInfo(data) {
            const lines = data.split('\n');
            let currentStructure = null;
            
            // 清空现有结构信息
            structureInfo = {};
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line === '') {
                    // 空行，跳过
                    continue;
                }
                
                // 检查是否是结构名称行（不是以"功能"或"纤维联系"开头的行）
                if (!line.startsWith('功能') && !line.startsWith('纤维联系')) {
                    currentStructure = line;
                    structureInfo[currentStructure] = {
                        function: '',
                        fiber: ''
                    };
                    continue;
                }
                
                // 检查是否是功能行
                if (line.startsWith('功能') && currentStructure) {
                    // 提取功能信息（去掉"功能:"部分）
                    const functionInfo = line.replace(/^功能:?\s*/, '');
                    structureInfo[currentStructure].function = functionInfo;
                    continue;
                }
                
                // 检查是否是纤维联系行
                if (line.startsWith('纤维联系') && currentStructure) {
                    // 提取纤维联系信息（去掉"纤维联系:"部分）
                    const fiberInfo = line.replace(/^纤维联系:?\s*/, '');
                    structureInfo[currentStructure].fiber = fiberInfo;
                    continue;
                }
            }
        }
        
        // 显示结构信息
        function showStructureInfo(structureName) {
            const structureInfoPanel = document.getElementById('structure-info-panel');
            const structureInfoContent = document.getElementById('structure-info-content');
            const structureNameElement = document.getElementById('structure-name');
            const structureFunctionElement = document.getElementById('structure-function');
            const structureFiberElement = document.getElementById('structure-fiber');
            
            if (structureInfo[structureName]) {
                structureNameElement.textContent = structureName;
                structureFunctionElement.textContent = structureInfo[structureName].function || '暂无信息';
                structureFiberElement.textContent = structureInfo[structureName].fiber || '暂无信息';
                structureInfoPanel.style.display = 'block';
            } else {
                hideStructureInfo();
            }
        }
        
        // 隐藏结构信息
        function hideStructureInfo() {
            document.getElementById('structure-info-panel').style.display = 'none';
        }
        
        // 更新加载状态
        function updateLoadingStatus(text, progress) {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('progress').style.width = `${progress}%`;
        }
        
        // 更新模型信息
        function updateModelInfo() {
            if (!model) return;
            
            let vertices = 0;
            let faces = 0;
            let meshes = 0;
            
            model.traverse((child) => {
                if (child.isMesh) {
                    meshes++;
                    const geometry = child.geometry;
                    if (geometry.index) {
                        faces += geometry.index.count / 3;
                    } else {
                        faces += geometry.attributes.position.count / 3;
                    }
                    vertices += geometry.attributes.position.count;
                }
            });
            
            document.getElementById('stats').textContent = 
                ``;
        }
        
        // 更新缩放信息显示
        function updateZoomInfo() {
            document.getElementById('zoom-value').textContent = `${zoomLevel}%`;
            document.getElementById('zoom-level').value = zoomLevel;
        }
        
        // 应用缩放
        function applyZoom() {
            if (model) {
                const scale = zoomLevel / 100;
                model.scale.set(scale, scale, scale);
            }
        }
        
        // 收集模型结构信息
        function collectPartsInfo() {
            if (!model) return;
            
            partsList = [];
            model.traverse((child) => {
                if (child.isMesh && child.name && child.name !== '') {
                    partsList.push({
                        name: child.name,
                        object: child,
                        parent: child.parent ? child.parent.name : '无'
                    });
                }
            });
        }
        
        // 更新隐藏结构计数
        function updateHiddenCount() {
            const hiddenCountElement = document.getElementById('hidden-count');
            if (hiddenParts.size > 0) {
                hiddenCountElement.textContent = `已隐藏 ${hiddenParts.size} 个结构`;
                hiddenCountElement.style.display = 'block';
            } else {
                hiddenCountElement.style.display = 'none';
            }
        }
        
        // 获取对象的世界位置
        function getObjectWorldPosition(object) {
            const worldPosition = new THREE.Vector3();
            object.getWorldPosition(worldPosition);
            return worldPosition;
        }
        
        // 高亮对象 - 修复切面查看时无法显示结构信息的问题
        function highlightObject(object, name) {
            // 清除之前的高亮
            clearHighlight();
            
            // 保存原始材质
            if (!originalMaterials.has(object)) {
                originalMaterials.set(object, object.material);
            }
            
            // 创建高亮材质 - 修复材质问题
            const highlightMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00aa00,
                emissiveIntensity : highlightIntensity,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide, // 确保双面渲染
                depthWrite: true, // 启用深度写入
                depthTest: true   // 启用深度测试
            });
            
            // 应用高亮材质
            object.material = highlightMaterial;
            highlightedObject = object;
            currentPartName = name;
            
            // 显示结构信息
            // const highlightInfo = document.getElementById('highlight-info');
            // highlightInfo.textContent = `选中结构: ${name}`;
            // highlightInfo.style.display = 'block';
            
            // 显示当前结构控制
            const currentPartControls = document.getElementById('current-part-controls');
            const currentPartNameElement = document.getElementById('current-part-name');
            const hidePartCheckbox = document.getElementById('hide-part');
            const sectionControls = document.getElementById('section-controls');
            
            currentPartNameElement.textContent = `当前结构: ${name}`;
            hidePartCheckbox.checked = hiddenParts.has(name);
            currentPartControls.style.display = 'block';
            
            // 检查是否是平面结构，显示切面控制
            if (name.endsWith('平面') || isSectionViewActive) {
                sectionControls.style.display = 'block';
                document.getElementById('view-section').checked = isSectionViewActive;
                
                // 如果是平面结构，获取其世界位置
                if (name.endsWith('平面')) {
                    const worldPosition = getObjectWorldPosition(object);
                    currentPlaneY = worldPosition.y;
                    
                    // 重置偏移量为0
                    sectionOffset = 0;
                    document.getElementById('section-offset').value = sectionOffset;
                    document.getElementById('section-offset-value').textContent = sectionOffset.toFixed(1);
                }
                
                // 更新方向按钮状态
                updateDirectionButtons();
                
                // 如果切面已激活，更新切面位置
                if (isSectionViewActive) {
                    createSectionView();
                }
                
                // 显示切面调节控件
                document.getElementById('section-slider-control').style.display = 'block';
                document.getElementById('section-direction-control').style.display = 'block';
                document.getElementById('reset-section').style.display = 'block';
                
                // 如果是平面结构，隐藏结构信息；否则显示结构信息
                if (name.endsWith('平面')) {
                    hideStructureInfo();
                } else {
                    showStructureInfo(name);
                }
            } else {
                sectionControls.style.display = 'none';
                
                // 显示结构信息
                showStructureInfo(name);
            }
        }
        
        // 更新方向按钮状态
        function updateDirectionButtons() {
            const upButton = document.getElementById('direction-up');
            const downButton = document.getElementById('direction-down');
            
            upButton.classList.toggle('active', sectionDirection === 'up');
            downButton.classList.toggle('active', sectionDirection === 'down');
        }
        
        // 清除高亮
        function clearHighlight() {
            if (highlightedObject && originalMaterials.has(highlightedObject)) {
                highlightedObject.material = originalMaterials.get(highlightedObject);
                originalMaterials.delete(highlightedObject);
            }
            
            highlightedObject = null;
            currentPartName = null;
            
            // 隐藏结构信息
            document.getElementById('highlight-info').style.display = 'none';
            
            // 隐藏当前结构控制
            document.getElementById('current-part-controls').style.display = 'none';
            
            // 隐藏结构信息
            hideStructureInfo();
        }
        
        // 隐藏/显示结构
        function togglePartVisibility(partName, hide) {
            if (!model) return;
            
            model.traverse((child) => {
                if (child.isMesh && child.name === partName) {
                    child.visible = !hide;
                }
            });
            
            if (hide) {
                hiddenParts.add(partName);
            } else {
                hiddenParts.delete(partName);
            }
            
            // 更新隐藏结构计数
            updateHiddenCount();
            
            // 如果当前高亮的结构被隐藏，保持控制面板显示
            // 只有当高亮转移到其他结构时，控制面板才会隐藏
            if (hide && currentPartName === partName) {
                // 更新复选框状态
                document.getElementById('hide-part').checked = true;
            }
        }
        
        // 显示所有结构
        function showAllParts() {
            if (!model) return;
            
            model.traverse((child) => {
                if (child.isMesh) {
                    child.visible = true;
                }
            });
            
            hiddenParts.clear();
            updateHiddenCount();
            
            // 如果当前有高亮的结构，更新复选框状态
            if (currentPartName) {
                document.getElementById('hide-part').checked = false;
            }
            
            // 重置切面查看
            resetSectionView();
        }
        
        // 创建切面
        function createSectionView() {
            // 计算实际切面位置 = 平面结构Y位置 + 偏移量
            const actualSectionPosition = currentPlaneY + sectionOffset;
            
            // 创建xOz平面裁剪平面 (法线为y轴方向)
            // 根据方向设置法线方向
            let normal, constant;
            
            if (sectionDirection === 'up') {
                // 上方切面：裁剪掉y > actualSectionPosition的部分
                normal = new THREE.Vector3(0, -1, 0);
                constant = actualSectionPosition; // 注意这里使用正值
            } else {
                // 下方切面：裁剪掉y < actualSectionPosition的部分
                normal = new THREE.Vector3(0, 1, 0);
                constant = -actualSectionPosition;
            }
            
            sectionPlane = new THREE.Plane(normal, constant);
            
            // 不再添加平面可视化辅助对象，直接应用裁剪平面
            // 为所有网格启用裁剪
            model.traverse((child) => {
                if (child.isMesh) {
                    // 确保材质支持裁剪
                    if (child.material) {
                        child.material.clippingPlanes = [sectionPlane];
                        child.material.clipShadows = true;
                    }
                }
            });
            
            // 启用渲染器裁剪
            renderer.localClippingEnabled = true;
            isSectionViewActive = true;
            
            // 确保切面调节控件显示
            document.getElementById('section-slider-control').style.display = 'block';
            document.getElementById('section-direction-control').style.display = 'block';
            document.getElementById('reset-section').style.display = 'block';
        }
        
        // 更新切面偏移
        function updateSectionOffset(offset) {
            sectionOffset = parseFloat(offset);
            document.getElementById('section-offset-value').textContent = sectionOffset.toFixed(1);
            
            if (isSectionViewActive) {
                createSectionView();
            }
        }
        
        // 设置切面方向
        function setSectionDirection(direction) {
            sectionDirection = direction;
            updateDirectionButtons();
            
            if (isSectionViewActive) {
                createSectionView();
            }
        }
        
        // 重置切面查看
        function resetSectionView() {
            // 不再需要移除平面辅助对象
            
            // 禁用所有网格的裁剪
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.clippingPlanes = null;
                }
            });
            
            // 禁用渲染器裁剪
            renderer.localClippingEnabled = false;
            isSectionViewActive = false;
            sectionOffset = 0;
            
            // 更新UI
            document.getElementById('view-section').checked = false;
            document.getElementById('section-offset').value = 0;
            document.getElementById('section-offset-value').textContent = '0';
            
            // 如果当前高亮的结构不是平面结构，隐藏切面调节控件
            if (!currentPartName || !currentPartName.endsWith('平面')) {
                document.getElementById('section-slider-control').style.display = 'none';
                document.getElementById('section-direction-control').style.display = 'none';
                document.getElementById('reset-section').style.display = 'none';
            }
        }
        
        // 检查结构是否可见（考虑隐藏和切面裁剪）
        function isPartVisible(part) {
            // 检查是否被手动隐藏
            if (hiddenParts.has(part.name) || !part.object.visible) {
                return false;
            }
            
            // 如果切面查看未启用，则结构可见
            if (!isSectionViewActive) {
                return true;
            }
            
            // 获取结构的边界框
            const bbox = new THREE.Box3().setFromObject(part.object);
            
            // 计算实际切面位置
            const actualSectionPosition = currentPlaneY + sectionOffset;
            
            // 根据切面方向检查结构是否在切面的可见一侧
            if (sectionDirection === 'up') {
                // 裁剪掉y > actualSectionPosition的部分，保留y <= actualSectionPosition的部分
                return bbox.max.y <= actualSectionPosition;
            } else {
                // 裁剪掉y < actualSectionPosition的部分，保留y >= actualSectionPosition的部分
                return bbox.min.y >= actualSectionPosition;
            }
        }
        
        // 检查点是否在切面的可见一侧
        function isPointVisible(point) {
            if (!isSectionViewActive) {
                return true;
            }
            
            // 计算实际切面位置
            const actualSectionPosition = currentPlaneY + sectionOffset;
            
            if (sectionDirection === 'up') {
                // 裁剪掉y > actualSectionPosition的部分，保留y <= actualSectionPosition的部分
                return point.y <= actualSectionPosition;
            } else {
                // 裁剪掉y < actualSectionPosition的部分，保留y >= actualSectionPosition的部分
                return point.y >= actualSectionPosition;
            }
        }
        
        // 修复材质问题 - 确保所有面都能正确显示
        function fixMaterials() {
            if (!model) return;
            
            model.traverse((child) => {
                if (child.isMesh) {
                    // 保存原始材质
                    if (!child.userData.originalMaterial) {
                        child.userData.originalMaterial = child.material;
                    }
                    
                    let material = child.material;
                    
                    // 确保材质是数组（处理多材质对象）
                    if (!Array.isArray(material)) {
                        material = [material];
                    }
                    
                    // 为每个材质设置双面渲染
                    material.forEach(mat => {
                        if (mat && mat.isMaterial) {
                            // 设置双面渲染
                            mat.side = THREE.DoubleSide;
                            
                            // 设置自发光强度
                            mat.emissiveIntensity = emissiveIntensity;
                            
                            // 确保材质属性正确设置
                            mat.needsUpdate = true;
                        }
                    });
                    
                    // 确保几何体正确计算法线
                    if (child.geometry) {
                        child.geometry.computeVertexNormals();
                    }
                }
            });
        }
        
        // 搜索结构
        function searchParts(query) {
            const resultsContainer = document.getElementById('search-results');
            resultsContainer.innerHTML = '';
            
            if (query.trim() === '') {
                resultsContainer.style.display = 'none';
                return;
            }
            
            const filteredParts = partsList.filter(part => 
                part.name.toLowerCase().includes(query.toLowerCase())
            );
            
            if (filteredParts.length === 0) {
                resultsContainer.innerHTML = '<div class="search-result-item">未找到匹配的结构</div>';
            } else {
                filteredParts.forEach(part => {
                    const resultItem = document.createElement('div');
                    resultItem.className = 'search-result-item';
                    resultItem.textContent = part.name;
                    if (hiddenParts.has(part.name)) {
                        resultItem.style.opacity = '0.5';
                        resultItem.style.textDecoration = 'line-through';
                    }
                    resultItem.addEventListener('click', () => {
                        highlightObject(part.object, part.name);
                        document.getElementById('part-search').value = '';
                        resultsContainer.style.display = 'none';
                    });
                    resultsContainer.appendChild(resultItem);
                });
            }
            
            resultsContainer.style.display = 'block';
        }
        
        // 加载模型
        function loadModel() {
            document.getElementById('loading').style.display = 'flex';
            updateLoadingStatus('加载模型中...', 10);
            
            // 清除之前的模型
            if (model) {
                scene.remove(model);
                model = null;
                partsList = [];
                hiddenParts.clear();
                clearHighlight();
                updateHiddenCount();
                document.getElementById('stats').textContent = '等待加载...';
            }
            
            // 创建GLTFLoader实例
            const loader = new THREE.GLTFLoader();
            
            updateLoadingStatus('解析模型数据...', 30);
            
            loader.load('model.glb', function(gltf) {
                updateLoadingStatus('添加模型到场景...', 70);
                
                model = gltf.scene;
                scene.add(model);
                
                // 修复材质问题
                fixMaterials();
                
                // 收集结构信息
                collectPartsInfo();
                
                // 计算模型的边界框，用于自动调整视角
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // 设置控制器目标为模型中心
                controls.target.copy(center);
                controls.update();
                
                // 更新模型信息
                updateModelInfo();
                
                updateLoadingStatus('模型加载完成!', 100);
                updateFileStatus('model-status', '模型加载成功', true);
                
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    isLoading = false;
                }, 500);
            }, function(xhr) {
                // 加载进度
                const percentComplete = (xhr.loaded / xhr.total) * 100;
                updateLoadingStatus(`加载模型中... ${Math.round(percentComplete)}%`, percentComplete);
            }, function(error) {
                console.error('加载模型时出错:', error);
                updateLoadingStatus('模型加载失败', 100);
                updateFileStatus('model-status', '模型加载失败', false, true);
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1500);
            });
        }
        
        // 初始化函数
        function init() {
            try {
                updateLoadingStatus('初始化场景...', 10);
                
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x2a2a2a); // 更暗的背景
                
                updateLoadingStatus('设置相机...', 20);
                
                // 创建相机
                const canvas = document.getElementById('model-viewer');
                camera = new THREE.PerspectiveCamera(60, 
                    canvas.clientWidth / canvas.clientHeight, 
                    0.1, 10000);
                camera.position.set(5, 5, 5);
                
                updateLoadingStatus('创建渲染器...', 40);
                
                // 创建渲染器
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // 禁用阴影
                renderer.shadowMap.enabled = false;
                
                updateLoadingStatus('添加控制器...', 60);
                
                // 添加轨道控制器
                try {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.autoRotate = false;
                    controls.autoRotateSpeed = 1.0;
                    
                    // 解除缩放限制
                    controls.minDistance = 0.1;
                    controls.maxDistance = 10000;
                    controls.zoomSpeed = 1.5;
                    
                    // 监听缩放事件
                    controls.addEventListener('change', function() {
                        if (model) {
                            const distance = camera.position.distanceTo(controls.target);
                            const baseDistance = 5;
                            zoomLevel = Math.max(1, Math.min(500, Math.round((baseDistance / distance) * 100)));
                            updateZoomInfo();
                        }
                    });
                    
                } catch (error) {
                    console.warn('OrbitControls初始化失败:', error);
                }
                
                updateLoadingStatus('设置光照...', 70);
                
                // 创建环绕型环境光 - 均匀照亮所有表面
                ambientLight = new THREE.AmbientLight(0xffffff, ambientIntensity);
                scene.add(ambientLight);
                
                // 创建定向光 - 从相机方向照射，跟随相机旋转
                directionalLight = new THREE.DirectionalLight(0xffffff, directionalIntensity);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);
                
                // 更新光照位置跟随相机
                controls.addEventListener('change', function() {
                    directionalLight.position.copy(camera.position);
                });
                
                updateLoadingStatus('准备就绪', 100);
                
                // 开始动画循环
                animate();
                
                // 窗口大小调整事件
                window.addEventListener('resize', onWindowResize);
                
                // 添加鼠标事件监听 - 用于区分旋转和点击
                canvas.addEventListener('mousedown', onMouseDown, false);
                canvas.addEventListener('mouseup', onMouseUp, false);
                canvas.addEventListener('mousemove', onMouseMove, false);
                
                // 加载模型和结构信息
                loadModel();
                loadStructureInfo();
                
                // 添加搜索功能事件监听
                document.getElementById('part-search').addEventListener('input', function() {
                    searchParts(this.value);
                });
                
                // 点击其他地方关闭搜索结果
                document.addEventListener('click', function(event) {
                    if (!event.target.matches('.search-input, .search-result-item')) {
                        document.getElementById('search-results').style.display = 'none';
                    }
                });
                
                // 添加隐藏结构复选框事件监听
                document.getElementById('hide-part').addEventListener('change', function() {
                    const currentPartName = document.getElementById('current-part-name').textContent.replace('当前结构: ', '');
                    togglePartVisibility(currentPartName, this.checked);
                });
                
                // 添加查看切面复选框事件监听
                document.getElementById('view-section').addEventListener('change', function() {
                    if (this.checked) {
                        createSectionView();
                    } else {
                        resetSectionView();
                    }
                });
                
                // 添加切面偏移滑块事件监听
                document.getElementById('section-offset').addEventListener('input', function() {
                    updateSectionOffset(this.value);
                });
                
                // 添加上方方向按钮事件监听
                document.getElementById('direction-up').addEventListener('click', function() {
                    setSectionDirection('up');
                });
                
                // 添加下方方向按钮事件监听
                document.getElementById('direction-down').addEventListener('click', function() {
                    setSectionDirection('down');
                });
                
                // 添加重置切面按钮事件监听
                document.getElementById('reset-section').addEventListener('click', function() {
                    resetSectionView();
                });
                
                // 添加关闭结构信息面板事件
                document.getElementById('close-info').addEventListener('click', function() {
                    hideStructureInfo();
                });
                
            } catch (error) {
                console.error('初始化Three.js时出错:', error);
                updateLoadingStatus('初始化失败', 100);
            }
        }
        
        // 鼠标按下事件
        function onMouseDown(event) {
            mouseDownPosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        // 鼠标移动事件
        function onMouseMove(event) {
            if (mouseDownPosition && !isRotating) {
                const dx = Math.abs(event.clientX - mouseDownPosition.x);
                const dy = Math.abs(event.clientY - mouseDownPosition.y);
                
                // 如果鼠标移动超过阈值，则认为是旋转操作
                if (dx > MOUSE_MOVE_THRESHOLD || dy > MOUSE_MOVE_THRESHOLD) {
                    isRotating = true;
                }
            }
        }
        
        // 鼠标释放事件
        function onMouseUp(event) {
            // 如果没有明显的移动，则认为是点击操作
            if (mouseDownPosition && !isRotating) {
                onCanvasClick(event);
            }
            
            // 重置状态
            mouseDownPosition = null;
            isRotating = false;
        }
        
        // 处理画布点击事件
        function onCanvasClick(event) {
            if (!model) return;
            
            // 计算鼠标在标准化设备坐标中的位置
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();
            
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // 创建射线投射器
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // 计算与模型相交的对象 - 只考虑可见的对象
            const intersects = [];
            
            // 遍历所有结构，只对未被手动隐藏的对象进行射线检测
            partsList.forEach(part => {
                if (!hiddenParts.has(part.name) && part.object.visible) {
                    const partIntersects = raycaster.intersectObject(part.object, true);
                    
                    // 过滤交点，只保留在切面可见一侧的交点
                    const visibleIntersects = partIntersects.filter(intersect => 
                        isPointVisible(intersect.point)
                    );
                    
                    if (visibleIntersects.length > 0) {
                        intersects.push(...visibleIntersects);
                    }
                }
            });
            
            // 按距离排序，找到最近的交点
            intersects.sort((a, b) => a.distance - b.distance);
            
            if (intersects.length > 0) {
                // 找到第一个相交的网格对象
                const intersect = intersects[0];
                let object = intersect.object;
                
                // 向上查找有名称的父对象
                while (object && (!object.name || object.name === '')) {
                    object = object.parent;
                }
                
                if (object && object.name) {
                    highlightObject(object, object.name);
                }
            } else {
                // 点击空白处清除高亮
                clearHighlight();
            }
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新脉动高亮效果
            if (highlightedObject) {
                pulseTime += 0.05;
                const pulseValue = (Math.sin(pulseTime) + 1) * 0.5 * 0.5 + 0.5; // 0.5 到 1.0 之间脉动
                highlightedObject.material.emissiveIntensity = highlightIntensity * pulseValue;
            }
            
            // 更新定向光位置跟随相机
            if (directionalLight) {
                directionalLight.position.copy(camera.position);
            }
            
            if (controls) {
                controls.update();
            }
            
            renderer.render(scene, camera);
        }
        
        // 窗口大小调整处理
        function onWindowResize() {
            const canvas = document.getElementById('model-viewer');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }
        
        // 初始化Three.js
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
        
        // 添加控制按钮事件
        document.getElementById('reset-view').addEventListener('click', function() {
            if (controls && controls.reset) {
                controls.reset();
            }
            camera.position.set(5, 5, 5);
            if (model) {
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                controls.target.copy(center);
            }
            controls.update();
            zoomLevel = 100;
            updateZoomInfo();
            
            // 重置切面查看
            resetSectionView();
        });
        
        // 显示所有结构按钮事件
        document.getElementById('show-all').addEventListener('click', function() {
            showAllParts();
        });
        
        // 缩放控制事件
        document.getElementById('zoom-level').addEventListener('input', function() {
            zoomLevel = parseInt(this.value);
            applyZoom();
            updateZoomInfo();
        });
    </script>
</body>

</html>
